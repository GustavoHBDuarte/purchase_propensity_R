---
title: "purchase_propensity_2"
author: "Gustavo Duarte"
date: "`r Sys.Date()`"
output: 
    html_document:
      highlight: textmate
      logo: logo.png
      theme: jou
      number_sections: no
      toc: yes
      toc_float:
        collapsed: yes
        smooth_scroll: no
      df_print: paged
      code_folding: hide
---

# 0 - Starting point

## 0.0 - Installing Packages

```{r results = 'hide'}
install.packages("tidyverse")
install.packages("janitor")
install.packages("skimr")
install.packages("gtsummary")
install.packages("summarytools")
install.packages("kableExtra")
install.packages("gridExtra")
install.packages("rsample")
install.packages("randomForest")
install.packages('C50')
install.packages('xgboost')
```

## 0.1 - Importing libraries

```{r results = 'hide'}
library(tidyverse)
library(readr) # leitura de arquivos .csv
library(janitor) # nomes de colunas em caixa baixa e espaços em _
library(skimr) # gera um dataframe de estatísticas para variáveis numéricas
library(gtsummary) # gera uma figura sumarizando as variáveis
library(summarytools)
library(rsample) # split de treino e teste
library(recipes) # receita de pré-processamento
library(randomForest)
library(parsnip) # modelos de ML
library(yardstick) # métricas de modelos de ML
```

# 1 - Data loading, checking, cleaning and description

```{r}
# Loading data:

df <- readr::read_csv("train.csv")
#View(df)
#dplyr::glimpse(df)
```

```{r}
# Checking first rows
df %>% head
```

```{r}
# Colocando nome das colunas em caixa baixa
df <- janitor::clean_names(df)

df %>% head
```

```{r}
# Data types

dplyr::tibble(features = colnames(df), 
              data_tipe = unlist(lapply(df, typeof))
              )
```

```{r}
# Data dimensions

dplyr::tibble( dimension = unlist(list("rows", "columns")),
               count = c(dim(df)[1], dim(df)[2]))
```

```{r}
# Checking NA's

dplyr::tibble(variable = colnames(df),
              number_of_missing = colSums(is.na(df)))
```

```{r}
# 1 - Replacing some column names (rename() function)

# 2 - Changing categorical columns elements to lowercase

# 3 - Changing 'vehicle_age' column values

# 4 - Changin character columns to factor

# função mutate: nome da variável, operação a fazer na variável
# função across: aplica uma função à multiplas colunas

df <- df %>% 
  
  # renomear colunas -> rename(nome_novo, nome_antigo)
  dplyr::rename(days_associated = vintage,
                health_annual_paid = annual_premium) %>% 
  
  # mutate(nome_da_variável, operacao)
  dplyr::mutate(
    
                # colunas categóricas -> valores em lowercase
                across(where(is.character), tolower),
                
                # colunas com valores 1 ou 0 -> substituir por "yes" ou "no"
                
                driving_license = ifelse(driving_license==1, "yes", "no"),
                
                previously_insured = ifelse(previously_insured==1, "yes", "no"),
                
                response = ifelse(response==1, "yes", "no"),
                
                # coluna "vehicle_age" -> substituindo os valores
                vehicle_age = case_when(
                                        vehicle_age == "< 1 year" ~ "less_than_1_year",
                                        vehicle_age == "1-2 year" ~ "between_1_and_2_years",
                                        vehicle_age == "> 2 years" ~ "more_than_1_year"
                                        )
    
               ) %>% 
  
  # convertendo variáveis de caracter p/ factor
  dplyr::mutate_if(is.character, as.factor)
  

```

```{r}
# Adjusting "yes"/"no" variables to ordered factor:

## Ajustando as variáveis de yes/no colocando "yes" no primeiro nível do factor

df <- df %>% mutate(
                    # response variable
                    response = factor(response, levels=c("yes", "no")),
                    
                    # driving_license
                    driving_license = factor(driving_license, levels=c("yes", "no")),
                    
                    # previously_insured
                    previously_insured = factor(previously_insured, levels=c("yes", "no")),
                    
                    # vehicle_damage
                    vehicle_damage = factor(vehicle_damage, levels=c("yes","no"))
                    )
```

```{r include=FALSE}
# Contando a quantidade de "yes" e "no" na variável resposta após a conversão p/ factor ord

df$response %>% table
```

```{r}
# Saving df as rds file
base::saveRDS(df, "df_cleaned.rds")
```

```{r}
# Loading RDS file
df <- base::readRDS("df_cleaned.rds")

df %>% head
```

```{r}
# Descripitive statistics

skimr::skim(df) 
```

```{r}
# Pacote gtsummary -> cria sumários de tabelas

df %>% 
  select(-id) %>% 
  gtsummary::tbl_summary(
                          type = list(response ~ "categorical",
                                      driving_license ~ "categorical",
                                      previously_insured ~ "categorical",
                                      vehicle_damage ~ "categorical"),
                          
                          digits = list(all_categorical() ~ c(0,2))
  )
```

Statistics of numerical attributes

```{r}
# Numerical attributes -> descriptive statistical evaluation

num_attributes <- df %>% 
                        select(age, days_associated, health_annual_paid) 
  
  
# comando abaixo gera um descritivo estatístico
num_attributes_stats <- descr(num_attributes, style = "rmarkdown") %>% 
  
                        round(2)

# comando abaixo formata/organiza a saída do comando acima
kableExtra::kable(data.frame(num_attributes_stats), format = "html") %>% 
                  
          kableExtra::kable_styling(bootstrap_options = "striped",
                                    full_width = FALSE)
```

Categorical attributes

```{r include=FALSE}
categ_attributes <- df %>% 
                        select(-id, -colnames(num_attributes)) 

categ_attributes
```

# 2 - EDA

## 2.1 Univariate

### 2.1.1 Numerical attributes

```{r include=FALSE}
# Histogram

# Age ================================

age_plot <- num_attributes %>% 
  
  ggplot(aes(x=age)) + # informar o dado que irá no eixo da figura
  
  geom_histogram(aes(y=after_stat(density)),
                 binwidth = 1,
                 color="red", 
                 fill="green",
                 alpha=0.5) + # alpha -> controla a transparência
  
  geom_density(color="blue") +
  
  labs(x= "Age", y= "Density", title = "Histograma de frequências para idade") +
  
  theme_bw()

age_plot  
```

```{r include=FALSE}
# Days associated ================================

days_associated_plot <- num_attributes %>% 
  
  ggplot(aes(x=days_associated)) + # informar o dado que irá no eixo da figura
  
  geom_histogram(aes(y=after_stat(density)),
                 binwidth = 50,
                 color="red", 
                 fill="green",
                 alpha=0.5) + # alpha -> controla a transparência
  
  geom_density(color="blue") +
  
  labs(x= "Days associated", y= "Density", title = "Histograma de frequências para Days associated") +
  
  theme_bw()

days_associated_plot
```

```{r include=FALSE}
# Health annual paid ================================

health_annual_paid_plot <- num_attributes %>% 
  
  ggplot(aes(x=health_annual_paid)) + # informar o dado que irá no eixo da figura
  
  geom_histogram(aes(y=after_stat(density)),
                 binwidth = 10000,
                 color="red", 
                 fill="green",
                 alpha=0.5) + # alpha -> controla a transparência
  
  geom_density(color="blue") +
  
  labs(x= "Health annual paid", y= "Density", title = "Histograma de frequências para Health annual paid") +
  
  theme_bw()

health_annual_paid_plot
```

```{r}
# Unir os 3 histogramas anteriores

gridExtra::grid.arrange(age_plot, days_associated_plot, health_annual_paid_plot,
                        ncol=3)
```

```{r include=FALSE}
# Removing unused objects

rm(num_attributes)
rm(num_attributes_stats)
rm(age_plot)
rm(days_associated_plot)
rm(health_annual_paid_plot)
gc()
```

### 2.2.2 Categorical attributes

```{r}

# Gender ============================================================
gender_plot <- categ_attributes %>% 
               ggplot(aes(x=gender)) +
               geom_bar(aes(fill=gender), color="black", show.legend = FALSE) +
               labs(x="Gender", y="Count", title = "Barplot of Gender") +
               theme_bw()

# Driving license ===================================================
driving_license_plot <- categ_attributes %>% 
                        ggplot(aes(x=driving_license)) +
                        geom_bar(aes(fill=driving_license), color="black", show.legend = FALSE) +
                        labs(x="Driving License", y="Count", title = "Barplot of Driving License") +
                        theme_bw()

# Previously insured ===============================================
previously_insuredr_plot <- categ_attributes %>% 
  ggplot(aes(x=previously_insured)) +
  geom_bar(aes(fill=previously_insured), color="black", show.legend = FALSE) +
  labs(x="Previously insured", y="Count", title = "Barplot of Previously insured") +
  theme_bw()


# Vehicle age ======================================================
vehicle_age_plot <- categ_attributes %>% 
                    ggplot(aes(x=vehicle_age)) +
                    geom_bar(aes(fill=vehicle_age), color="black", show.legend = FALSE) +
                    labs(x="Vehicle age", y="Count", title = "Barplot of Vehicle age") +
                    theme_bw()


# Vehicle demage ==================================================
vehicle_damage_plot <- categ_attributes %>% 
                    ggplot(aes(x=vehicle_damage)) +
                    geom_bar(aes(fill=vehicle_damage), color="black", show.legend = FALSE) +
                    labs(x="Vehicle demage", y="Count", title = "Barplot of Vehicle demage") +
                    theme_bw()


# Response =======================================================
response_plot <- categ_attributes %>% 
                 ggplot(aes(x=response)) +
                 geom_bar(aes(fill=response), color="black", show.legend = FALSE) +
                 labs(x="Response", y="Count", title = "Barplot of Response") +
                 theme_bw()




# Figura multipainéis

gridExtra::grid.arrange(gender_plot, driving_license_plot, previously_insuredr_plot,
                        vehicle_age_plot, vehicle_damage_plot, response_plot,
                        ncol=3)
```

```{r include=FALSE}
# Getting rid of unused objects

rm(categ_attributes)
rm(driving_license_plot)
rm(gender_plot)
rm(previously_insuredr_plot)
rm(response_plot)
rm(vehicle_age_plot)
rm(vehicle_damage_plot)
gc()
```

## 2.2 Bivariate

### Numéricas X Numéricas

```{r}
# Numéricas -> age X health_annual_paid

df %>%
      select(age, region_code, days_associated, health_annual_paid, response) %>%
      
      ggplot(aes(x=age, y=health_annual_paid),) + 
      
      geom_point(aes(color=response))

```

### Numéricas X Categóricas

```{r}
df %>% 
      ggplot(aes(y=age, x=gender)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=gender), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="gender", title="Response (Yes/No) -> Age X Gender")
  
```

```{r}
df %>% 
      ggplot(aes(y=age, x=vehicle_age)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=vehicle_age), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="Vehicle Age", title="Response (Yes/No) -> Age X Vehicle Age") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks
```

```{r}
df %>% 
      ggplot(aes(y=age, x=driving_license)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=driving_license), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="Driving license", title="Response (Yes/No) -> Age X Driving License")
```

```{r}
df %>% 
      ggplot(aes(y=age, x=vehicle_damage)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=vehicle_damage), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="Vehicle damage", title="Response (Yes/No) -> Age X Vehicle damage")
```

```{r}
df %>% 
      ggplot(aes(y=health_annual_paid, x=gender)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=gender), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="gender", title="Response (Yes/No) -> Health annual paid X Gender")
```

```{r}
df %>% 
      ggplot(aes(y=health_annual_paid, x=vehicle_age)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=vehicle_age), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="health_annual_paid", title="Response (Yes/No) -> Health Annual Paid X Vehicle Age") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks

```

```{r}
df %>% 
      ggplot(aes(y=health_annual_paid, x=driving_license)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=driving_license), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="Driving license", title="Response (Yes/No) -> Health annual paid X Driving License")
```

```{r}
df %>% 
      ggplot(aes(y=health_annual_paid, x=vehicle_damage)) +
      stat_boxplot(geom='errorbar', width=0.6) +
      geom_boxplot(aes(fill=vehicle_damage), show.legend = FALSE) +
      facet_wrap(vars(response)) +
      labs(x="Vehicle damage", title="Response (Yes/No) -> Health annual paid X Vehicle damage")
```

```{r}
df %>% 
  select(age, response) %>% 
  ggplot(aes(x=age)) +
  geom_histogram(binwidth = 5, aes(fill=response)) +
  facet_wrap(vars(response), nrow=2, scales="free_y") +
  labs(title="Age histogram")

```

```{r}

# Variável Age é diferente entre Response yes e no?

df %>% 
  select(age, response) %>% 
  gtsummary::tbl_summary(by=response, list(response ~ "categorical")) %>% 
  add_p()
```

### Categóricas X Categóricas

```{r}
# Vehicle age X Gender

df %>% 
  ggplot(aes(x=vehicle_age)) +
  geom_bar(aes(fill=gender), position = "dodge") +
  facet_wrap(vars(response), scales="free_y") +
  labs(x="Vehicle age", title="Response (Yes/No) -> Vehicle age X Gender") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks
```

```{r}
# Vehicle age X Vehicle damage

df %>% 
  ggplot(aes(x=vehicle_age)) +
  geom_bar(aes(fill=vehicle_damage), position = "dodge") +
  facet_wrap(vars(response), scales="free_y") +
  labs(x="Vehicle age", title="Response (Yes/No) -> Vehicle age X Vehicle damage") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks
```

```{r}
# Vehicle age X Driving licence
 
df %>% 
  ggplot(aes(x=vehicle_age)) +
  geom_bar(aes(fill=driving_license), position = "dodge") +
  facet_wrap(vars(response), scales="free_y") +
  labs(x="Vehicle age", title="Response (Yes/No) -> Vehicle age X Driving license") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks
```

```{r}
# Vehicle damage X Gender

df %>% 
  ggplot(aes(x=vehicle_damage)) +
  geom_bar(aes(fill=gender), position = "dodge") +
  facet_wrap(vars(response), scales="free_y") +
  labs(x="Vehicle Damage", title="Response (Yes/No) -> Vehicle Damage X Gender") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks
```

```{r}
# Vehicle damage X Driving license

df %>% 
  ggplot(aes(x=vehicle_damage)) +
  geom_bar(aes(fill=driving_license), position = "dodge") +
  facet_wrap(vars(response), scales="free_y") +
  labs(x="Vehicle Damage", title="Response (Yes/No) -> Vehicle Damage X Driving license") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks
```

```{r}
# Driving license X Gender

df %>% 
  ggplot(aes(x=gender)) +
  geom_bar(aes(fill=driving_license), position = "dodge") +
  facet_wrap(vars(response), scales="free_y") +
  labs(x="Gender", title="Response (Yes/No) -> Gender X Driving license") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # rotacionar x ticks
```

## 2.3 Multivariate

```{r}
# Correlação entre variáveis numéricas

df %>% 
  select(age, health_annual_paid, days_associated) %>% 
  cor %>%
  as.table %>% 
  data.frame %>% 
  ggplot(aes(Var1, Var2, fill = Freq, label = round(Freq, 2))) +
  geom_tile() +
  geom_text(color = "black") + # exibit o valor numérico das correlações
  scale_fill_gradient(low = "lightgreen", high = "green") +
  theme_minimal() +
  labs(x = "", y = "") +
  theme(legend.position = "right") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(fill = guide_colorbar(title = "Correlation"))
```

```{r}

```

```{r}
# Função para calcular a correlação Cramer V =================================
cramer_v <- function(x, y) {
  contingency_table <- table(x, y)
  chi2 <- chisq.test(contingency_table)$statistic
  n <- sum(contingency_table)
  phi2 <- chi2 / n
  r <- min(length(unique(x)) - 1, length(unique(y)) - 1)
  cramer_v <- sqrt(phi2 / r)
  return(cramer_v)
}
```

```{r}
categorical_data <- df %>% 
  select(gender, vehicle_age, vehicle_damage, driving_license, response)

# Calcular a matriz de correlação Cramer V
correlation_matrix <- outer(
  names(categorical_data),
  names(categorical_data),
  Vectorize(function(x, y) cramer_v(categorical_data[[x]], categorical_data[[y]])
  )
)

# Atribuir nomes às linhas e colunas da matriz de correlação
colnames(correlation_matrix) <- rownames(correlation_matrix) <- names(categorical_data)

# Transformar a matriz em um tibble longo
correlation_data <- as.data.frame(as.table(correlation_matrix))
names(correlation_data) <- c("Var1", "Var2", "Freq")

ggplot(data = correlation_data, aes(x = Var1, y = Var2, fill = Freq, label = round(Freq, 2))) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue") +
  theme_minimal() +
  labs(x = "", y = "") +
  labs(title = "Cramer's V correlation heatmap") +
  geom_text(size = 3, color = "black") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  guides(fill = guide_colorbar(title = "Correlation"))
```

```{r}
# Eliminando objetos adicionais

rm(categorical_data)
rm(correlation_data)
rm(correlation_matrix)
rm(cramer_v)
```

# 3 - Data preparation

## 3.1 Train/test split

```{r}
# Setting seed
base::set.seed(123)

# Definindo o objeto splitter
splitter <- df %>% 
                  rsample::initial_split(prop = 0.75, strata = response)

# Train split
df_train <- splitter %>% 
                        rsample::training()

# Test split
df_test <- splitter %>%
                        rsample::testing()
```

```{r}
## Checking response variable proportions
#
#df_train %>% 
#  select(response) %>% 
#  tbl_summary(type = list(response ~ "categorical"))
#
#
#df_test %>% 
#  select(response) %>% 
#  tbl_summary(type = list(response ~ "categorical"))
#
```

## 3.2 Preprocessing

```{r}

# ========================== Transformações nos dados ==============================

# Normalização (transformar para média 1 e std 0) -> age, days_associated

# Scale (transformar para std 1) -> health_annual_paid

# ===================================================================================


# Definindo a receita

reciper <- recipes::recipe(response ~.,
                           data=df_train) %>% 
                    step_normalize(age, days_associated) %>% # transformar para média 1 e std 0
                    step_scale(health_annual_paid) %>% # transformar para std 1
                    step_dummy(driving_license,
                               previously_insured,
                               vehicle_age,
                               vehicle_damage, -all_outcomes()) # transformar para one-hot


# Preparando a receita
recipe_preparer <- reciper %>% 
                      prep(training = df_train)

# Cozinhando a receita (processando o dado)

df_train <- recipe_preparer %>% 
                      bake(new_data = df_train)

df_test <- recipe_preparer %>% 
                      bake(new_data = df_test)
```

```{r}
rm(splitter)
rm(recipe_preparer)
rm(reciper)
rm(df)
```

```{r}

# ========================================
# Target encoding -> gender, region_code
# ========================================

# Definindo os encoders para "gender" e "region_code":

# Gender -> target encoding (proportion of "yes" in gender values)
gender_encoder <-  df_train %>% 
                    mutate(response_num = ifelse(response == "yes", 1,0)) %>% 
                    group_by(gender) %>%
                    summarise(gender_num = mean(response_num, na.rm= TRUE))


# Region code -> target encoding (proportion of "yes" in region_code values)
region_code_encoder <-  df_train %>% 
                    mutate(response_num = ifelse(response == "yes", 1,0)) %>% 
                    group_by(region_code) %>%
                    summarise(region_code_num = mean(response_num, na.rm= TRUE))

region_code_encoder
```

```{r}
# ============================================
# Frequency encoding -> policy_sales_channel
# ============================================

# Gerando a proporção de vezes que cada nível da variável "policy_sales_channel_num" aparece

# Definindo o encoder:

policy_sales_channel_encoder <- df_train %>% 
                                group_by(policy_sales_channel) %>% 
                                summarise(policy_sales_channel_num = n()/dim(df_train)[1])
```

```{r}
# Saving encoders

saveRDS(gender_encoder, "gender_encoder.rds")
saveRDS(region_code_encoder, "region_code_encoder.rds")
saveRDS(policy_sales_channel_encoder, "policy_sales_channel_encoder.rds")
```

```{r}
# Applying encoders

# Loading encoders
gender_encoder <- readRDS("gender_encoder.rds")
region_code_encoder <- readRDS("region_code_encoder.rds")
policy_sales_channel_encoder <- readRDS("policy_sales_channel_encoder.rds")
```

```{r}

# Applying loaded encoders:

# Gender

df_train <- df_train %>% 
            left_join(gender_encoder) %>% 
            select(-gender) %>% 
            rename(gender = gender_num)

df_test <- df_test %>% 
            left_join(gender_encoder) %>% 
            select(-gender) %>% 
            rename(gender = gender_num)


# Region code

df_train <- df_train %>% 
            left_join(region_code_encoder) %>% 
            select(-region_code) %>% 
            rename(region_code = region_code_num)

df_test <- df_test %>% 
            left_join(region_code_encoder) %>% 
            select(-region_code) %>% 
            rename(region_code = region_code_num)



# Policy sales channel

df_train <- df_train %>% 
            left_join(policy_sales_channel_encoder) %>% 
            select(-policy_sales_channel) %>% 
            rename(policy_sales_channel = policy_sales_channel_num)

df_test <- df_test %>% 
            left_join(policy_sales_channel_encoder) %>% 
            select(-policy_sales_channel) %>% 
            rename(policy_sales_channel = policy_sales_channel_num)
```

```{r}
# Removing objects

rm(gender_encoder)
rm(policy_sales_channel_encoder)
rm(region_code_encoder)
```

```{r}
df_train

```

## 3.3 Feature selection

```{r}
# Feature selection

# Selecionando os preditores e a variável resposta

predictors <- df_train %>% 
  select(-id, -response)

target <- df_train['response']

target <- df_train$response
```

```{r}
# Treinando o classificador


# OBSERVAÇÕES IMPORTANTES:

# 1- A variável resposta deve ser passada como um vetor de valores
# 2- O comprimento (função lenght) de preditores e do target deve ser o mesmo


# No dataframe dos preditores serão removidas as colunas "id" e "response" pois ambas
# não são features do modelo

start_time <- Sys.time() # coletando o tempo do início da execução

rf_feature_selector <- randomForest::randomForest(df_train %>% 
                                                    select(-id, -response), # preditores
                                                  df_train$response, # target
                                                  importance = TRUE,
                                                  ntree=10)


end_time <- Sys.time() # coletando o tempo do início da execução


#calculando o tempo total da execução
total_time <- end_time - start_time 



print(total_time)
```

```{r}

importance(rf_feature_selector)
```

```{r}
varImpPlot(rf_feature_selector)
```

```{r}
# 7 variáveis mais significativas/importantes


important_features <- 
  
  importance(rf_feature_selector) %>% 
  
  as_tibble(rownames='rowname') %>% # converter o objeto como tibble
  
  arrange(desc(MeanDecreaseGini)) %>% #fazer o sort decrescente
  
  select(rowname) %>% # selecionar a coluna com o nome das variáveis
  
  slice(1:7) %>% # fazer o slicing das 7 features mais importantes
  
  pull() # converter o tibble de 1 coluna para um vetor de valores


important_features
```

```{r}
# Filtrar as variáveis selecionadas no df

df_train %>% 
  select(all_of(important_features))
```

```{r}
# Removing variables

rm(rf_feature_selector)
rm(total_time)
rm(start_time)
rm(end_time)
```

# 4 - Machine learning

## 4.1 - Logistic Regression

```{r}
# Logistic regression

# Model definition:
lr_model <- logistic_reg() %>% 
  set_engine("glm") %>% 
  set_mode("classification")


# Model training
set.seed(123)
  lr_model_fit <- lr_model %>% fit(response~ .,
                                   data = df_train %>% select(all_of(important_features), response))
  

# Model predictions
class_predictions <- lr_model_fit %>% predict(new_data = df_test %>% select(all_of(important_features), -response), type = 'class')

prob_predictions <- lr_model_fit %>% predict(new_data = df_test %>% select(all_of(important_features), -response), type = 'prob')

# Results

lr_results <- df_test %>% select(id, response) %>% bind_cols(class_predictions, prob_predictions)


# Confusion matrix

lr_confusion_matrix <- lr_results %>% yardstick::conf_mat(truth=response,
                                                          estimate = .pred_class)
```

```{lr_results %>% yardstick::conf_mat(truth=response,                                                        estimate = .pred_class)}
```

## 4.2 - Decision Tree

```{r}
# Decision Tree

# Model definition:
dt_model <- decision_tree() %>% 
  set_engine("C5.0") %>% 
  set_mode("classification")


# Model training
set.seed(123)
  dt_model_fit <- dt_model %>% fit(response~ .,
                                   data = df_train %>% select(all_of(important_features), response))
  

# Model predictions
class_predictions <- dt_model_fit %>% predict(new_data = df_test %>% select(all_of(important_features), -response), type = 'class')

prob_predictions <- dt_model_fit %>% predict(new_data = df_test %>% select(all_of(important_features), -response), type = 'prob')

# Results

dt_results <- df_test %>% select(id, response) %>% bind_cols(class_predictions, prob_predictions)


# Confusion matrix

dt_confusion_matrix <- dt_results %>% yardstick::conf_mat(truth=response,
                                                          estimate = .pred_class)
```

```{r}

```

```{r}
dt_results %>% yardstick::conf_mat(truth=response,
                                                          estimate = .pred_class)
```

## 4.3 XGBoost

```{r}
# XGBoost

# Model definition:
xgb_model <- boost_tree(trees = 15) %>% 
  set_engine("xgboost") %>% 
  set_mode("classification")


# Model training
set.seed(123)
  xgb_model_fit <- xgb_model %>% fit(response~ .,
                                   data = df_train %>% select(all_of(important_features), response))
  

# Model predictions
class_predictions <- xgb_model_fit %>% predict(new_data = df_test %>% select(all_of(important_features), -response), type = 'class')

prob_predictions <- xgb_model_fit %>% predict(new_data = df_test %>% select(all_of(important_features), -response), type = 'prob')

# Results

xgb_results <- df_test %>% select(id, response) %>% bind_cols(class_predictions, prob_predictions)


# Confusion matrix

xgb_confusion_matrix <- xgb_results %>% yardstick::conf_mat(truth=response,
                                                          estimate = .pred_class)
```

```{r}
xgb_results %>% yardstick::conf_mat(truth=response,
                                                          estimate = .pred_class)
```

```{r}
# Armazenando os modelos em disco

saveRDS(lr_model_fit, "LogisticRegression_fitted.rds")
saveRDS(dt_model_fit, "DecisionTree_fitted.rds")
saveRDS(xgb_model_fit, "XGB_fitted.rds")
```

```{r}
# Removing model objects to release memory

rm(lr_model_fit)
rm(dt_model_fit)
rm(xgb_model_fit)
rm(lr_model)
rm(dt_model)
rm(xgb_model)
```

```{r}
xgb_model_fit <-  base::readRDS("XGB_fitted.rds")
```

```{}
```
